# 递推与递归

## Fibonacci数列的递归解法

```cpp
#include<iostream>
using namespace std;
int fibonacci_recursion(int n){
    if (n < 2) {
        return 1;
    }
    return fibonacci_recursion(n-1)+fibonacci_recursion(n-2);
}
int main() 
{
    for (int i=0; i<10; i++) 
	{
        cout<<fibonacci_recursion(i)<<" ";
    }
    return 0;
}
```


## 辗转相除法求最大公约数


辗转相除算法，又名欧几里德算法(Euclidean algorithm)，乃求两个正整数之最大公约数的算法。它是已知最古老的算法, 其可追溯至公元前300年。
若 a=bq+r,则a和b的最大公因子等于b和r的最大公因子绝对值（都为整数）。

即，f(a,b)=f(b,r),又，r=a%b,故，f(a,b)=f(b,a%b)

### 递推式

```cpp
int gcd(int m,int n)
{
    if(m<n) //m为最大的
    {
        int tmp=m;
        m=n;
        n=tmp;
    }
    if(n==0)
        return m; //除了0以外的所有自然数都是0的约数。
    while(n!=0)
    {
        int tmp=m%n;
        m=n;
        n=tmp;
    }
    return m;
}
```

### 递归式

```cpp
#include <iostream>
int gcd2(int m,int n)
{
    if(m<n)
    {
        int tmp=m;
        m=n;
        n=tmp;
    }
    if(n==0)
        return m;  //这个很关键
        
    else
        return gcd2(n,m%n);

}
int main()
{
	int a;
	a=gcd2(100,60);
	std::cout<<a;
}
```


### 约瑟夫环问题的递归解法

约瑟夫环中，每当有一个人出圈，出圈的人的下一个人成为新的环的头，相当于把数组向前移动 m 位。若已知 n-1 个人时，胜利者的下标位置位 f(n−1,m) ，则 n 个人的时候，就是往后移动 m 位，(因为有可能数组越界，超过的部分会被接到头上，所以还要%n )，根据此推导过程得到的计算公式为：
  f(n,m) = (f(n−1,m) + m) % n。
其中，f(n,m) 表示 n 个人进行报数时，每报到 m 时杀掉那个人，最终的编号，f(n−1,m) 表示，n-1 个人报数，每报到 m 时杀掉那个人，最终胜利者的编号。有了递推公式后即可使用递归的方式实现。

**递归实现**

假设下标从0开始，0，1，2 .. m-1共m个人，从1开始报数，报到k则此人从环出退出，问最后剩下的一个人的编号是多少？

现在假设m=10

0 1 2 3  4 5 6 7 8 9    k=3

第一个人出列后的序列为：

0 1 3 4 5 6 7 8 9

即:

3 4 5 6 7 8 9 0 1（*）

我们把该式转化为:

0 1 2 3 4 5 6 7 8 (**)

则你会发现: （(**)+3）%10则转化为(*)式了

也就是说，我们求出9个人中第9次出环的编号，最后进行上面的转换就能得到10个人第10次出环的编号了 

设f(m,k,i)为m个人的环，报数为k，第i个人出环的编号，则f(10,3,10)是我们要的结果

当i=1时，  f(m,k,i) = (m+k-1)%m

当i!=1时，  f(m,k,i)= ( f(m-1,k,i-1)+k )%m

所以程序如下：

```cpp

int fun(int m,int k,int i){
 
    if(i==1)
        return (m+k-1)%m;
    else
        return (fun(m-1,k,i-1)+k)%m;
 
}
int main(int argc, char* argv[])
{
     
    for(int i=1;i<=10;i++)
        printf("第%2d次出环：%2d\n",i,fun(10,3,i));
    return 0;
}

```

**迭代实现**

```cpp
#include <stdio.h>
/*计算约瑟夫环问题的迭代法函数*/
#include <stdio.h>
int main() {
	int n, m, i, result;
	while (scanf("%d", &n) == 1) {
		if (!n) {
			break;
		}
		scanf("%d", &m);
		result = 0;
		for (i = 2; i <= n; i++) {
			result = (result + m) % i;
		}
		printf("%d\n", result + 1);
	}
	return 0;
}
```

